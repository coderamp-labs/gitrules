<!-- Right Panel: Add tools -->
<div class="workspace-actions" style="height: 100%; display: flex; flex-direction: column;">
    <div class="p-4 flex-1 overflow-y-auto">
        <h3 class="text-lg font-black text-black mb-4">Add tools</h3>
        
        <!-- QuickAction Section - Search Bar -->
        <div class="mb-4">
            <div class="search-container">
                <input 
                    type="text" 
                    class="search-input"
                    placeholder="Search actions, tags..."
                    onkeyup="filterActions(this.value)"
                    onkeydown="handleSearchKeydown(event)"
                />
                <div class="search-clear" id="search-clear" style="display: none;" onclick="clearSearch()">×</div>
            </div>
        </div>

        <!-- Toggle Menu Buttons -->
        <div class="mb-4">
            <h4 class="text-sm font-bold text-black mb-2">Actions</h4>
            
            <!-- MCPs Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="yellow"
                    onclick="toggleMenuButton(this, 'mcps')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">MCPs</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-mcps" style="display: none;">
                    <div id="mcps-list" class="p-2">
                        {% for mcp in mcps %}
                        <div class="dropdown-item" onclick="toggleDropdownItem(this, '{{ mcp.name }}', 'mcps')">
                            <span class="dropdown-item-icon">+</span>
                            <span>{{ mcp.name }}</span>
                        </div>
                        {% endfor %}
                        {% if not mcps %}
                        <div class="text-xs text-gray-500">No MCPs available</div>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- Rules Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="pink"
                    onclick="toggleMenuButton(this, 'rules')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">Rules</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-rules" style="display: none;">
                    <div id="rules-list" class="p-2">
                        {% for rule in rules %}
                        <div class="dropdown-item {% if rule.type == 'ruleset' %}ruleset-item{% endif %}" 
                             {% if rule.type == 'ruleset' %}
                             onclick="toggleRuleset(event, this, '{{ rule.slug }}')"
                             {% else %}
                             onclick="toggleDropdownItem(this, '{{ rule.slug or rule.name }}', 'rules')"
                             {% endif %}
                             data-rule-type="{{ rule.type }}"
                             data-rule-slug="{{ rule.slug }}">
                            {% if rule.type == 'ruleset' %}
                            <span class="dropdown-item-checkbox" onclick="toggleRulesetItems(event, '{{ rule.slug }}')">+</span>
                            <span class="flex-1">{{ rule.display_name or rule.name }}</span>
                            <span class="ruleset-expand">▲</span>
                            {% else %}
                            <span class="dropdown-item-icon">+</span>
                            <span>{{ rule.display_name or rule.name }}</span>
                            {% endif %}
                        </div>
                        {% if rule.type == 'ruleset' and rule.children %}
                        <div class="ruleset-children" id="children-{{ rule.slug }}" style="display: none; margin-left: 20px;">
                            <!-- Children will be populated by JavaScript -->
                        </div>
                        {% endif %}
                        {% endfor %}
                        {% if not rules %}
                        <div class="text-xs text-gray-500">No rules available</div>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- Agents Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="blue"
                    onclick="toggleMenuButton(this, 'agents')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">Agents</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-agents" style="display: none;">
                    <div id="agents-list" class="p-2">
                        {% for agent in agents %}
                        <div class="dropdown-item" onclick="toggleDropdownItem(this, '{{ agent.slug or agent.name }}', 'agents')">
                            <span class="dropdown-item-icon">+</span>
                            <span>{{ agent.display_name or agent.name }}</span>
                        </div>
                        {% endfor %}
                        {% if not agents %}
                        <div class="text-xs text-gray-500">No agents available</div>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Next/Generate Button -->
        <div class="mt-auto p-4 border-t-2 border-black">
            <button 
                id="generate-files-btn"
                onclick="showFinalStep()"
                class="w-full py-3 bg-cyan-400 border-2 border-black text-black font-bold shadow-[3px_3px_0px_0px_rgba(0,0,0,1)] hover:shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] hover:translate-x-[-1px] hover:translate-y-[-1px] active:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:translate-x-[1px] active:translate-y-[1px] transition-all"
            >
                Next → Generate Files
            </button>
        </div>
    </div>
</div>

<style>
/* Workspace actions sidebar */
.workspace-actions {
    background: white;
    border-left: 2px solid black;
    min-height: 100%;
    height: 100%;
}

/* Search Container */
.search-container {
    position: relative;
}

.search-input {
    width: 100%;
    padding: 8px 32px 8px 12px;
    border: 2px solid black;
    font-size: 14px;
    background: white;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    transition: all 150ms ease;
}

.search-input:focus {
    outline: none;
    box-shadow: 3px 3px 0px 0px rgba(0,0,0,1);
    transform: translate(-1px, -1px);
}

.search-clear {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    color: #666;
    border-radius: 50%;
    transition: all 150ms ease;
}

.search-clear:hover {
    background: #f3f4f6;
    color: black;
}

.search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 4px;
    background: white;
    border: 2px solid black;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    max-height: 200px;
    overflow-y: auto;
    z-index: 10;
}

.search-result-item {
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    align-items: center;
    gap: 6px;
}

.search-result-item:last-child {
    border-bottom: none;
}

.search-result-item:hover {
    background: #f3f4f6;
}

.search-result-type {
    font-size: 10px;
    font-weight: bold;
    padding: 2px 4px;
    border: 1px solid black;
    background: #f3f4f6;
}

/* Menu Button Base Style */
.menu-button {
    width: 100%;
    display: flex;
    align-items: center;
    background: white;
    border: 2px solid black;
    padding: 0;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    transition: all 150ms ease;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    position: relative;
    overflow: hidden;
}

/* Plus icon area */
.menu-button-plus {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    font-weight: bold;
    border-right: 2px solid black;
    flex-shrink: 0;
}

/* Text area */
.menu-button-text {
    flex: 1;
    padding: 0 12px;
    color: black;
    text-align: left;
}

/* Expand arrow */
.menu-button-expand {
    padding: 0 12px;
    font-size: 12px;
    color: black;
    transition: transform 150ms ease;
}

/* Theme colors for plus area (default state) */
.menu-button[data-theme="yellow"] .menu-button-plus {
    background: #FDE047;
}

.menu-button[data-theme="pink"] .menu-button-plus {
    background: #F472B6;
}

.menu-button[data-theme="blue"] .menu-button-plus {
    background: #22D3EE;
}

/* Toggled state - color inversion (color moves to text area) */
.menu-button.toggled[data-theme="yellow"] {
    background: #FDE047;
}

.menu-button.toggled[data-theme="yellow"] .menu-button-plus {
    background: white;
}

.menu-button.toggled[data-theme="pink"] {
    background: #F472B6;
}

.menu-button.toggled[data-theme="pink"] .menu-button-plus {
    background: white;
}

.menu-button.toggled[data-theme="blue"] {
    background: #22D3EE;
}

.menu-button.toggled[data-theme="blue"] .menu-button-plus {
    background: white;
}

/* Text always stays black */
.menu-button .menu-button-text,
.menu-button.toggled .menu-button-text {
    color: black;
}

/* Expanded state */
.menu-button.expanded .menu-button-expand {
    transform: rotate(180deg);
}

/* Hover effect */
.menu-button:hover {
    box-shadow: 3px 3px 0px 0px rgba(0,0,0,1);
    transform: translate(-1px, -1px);
}

/* Active/pressed effect */
.menu-button:active {
    box-shadow: 1px 1px 0px 0px rgba(0,0,0,1);
    transform: translate(1px, 1px);
}

/* Dropdown container */
.menu-dropdown {
    background: white;
    border: 2px solid black;
    border-top: none;
    margin-top: -2px;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
}

/* List items in dropdown */
.dropdown-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    font-size: 12px;
    cursor: pointer;
    transition: background 100ms ease;
}

.dropdown-item:hover {
    background: #f3f4f6;
}

.dropdown-item.active {
    background: #e5e7eb;
    font-weight: bold;
}

.dropdown-item-icon {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    border: 1px solid black;
}

.dropdown-item.active .dropdown-item-icon {
    background: black;
    color: white;
}

/* Ruleset specific styles */
.ruleset-item {
    font-weight: 600;
    gap: 4px;
    justify-content: space-between;
}

.ruleset-expand {
    transition: transform 150ms ease;
    flex-shrink: 0;
    margin-left: auto;
    font-size: 10px;
    width: 12px;
    height: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.ruleset-item:not(.expanded) .ruleset-expand {
    transform: rotate(180deg);  /* ▲ becomes ▼ */
}

.ruleset-item.expanded .ruleset-expand {
    transform: rotate(0deg);  /* ▲ stays as ▲ */
}

.dropdown-item-checkbox {
    width: 16px;
    height: 16px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    border: 1px solid black;
    cursor: pointer;
    flex-shrink: 0;
}

.dropdown-item-checkbox:hover {
    background: #f3f4f6;
}

.dropdown-item-checkbox.checked {
    background: black;
    color: white;
}

.dropdown-item-checkbox.partial {
    background: #6b7280;
    color: white;
}

.ruleset-children {
    border-left: 2px solid #e5e7eb;
    margin-bottom: 8px;
}

.ruleset-children .dropdown-item {
    font-size: 11px;
}

/* Search filtering */
.menu-item.filtered-hidden,
.dropdown-item.filtered-hidden {
    display: none !important;
}

.search-match {
    background: #fef3c7;
}
</style>

<script>
// Initialize actions data from server-side rendering
const serverActions = {
    agents: {{ agents | tojson | safe }},
    rules: {{ rules | tojson | safe }},
    mcps: {{ mcps | tojson | safe }}
};

// Store all rules by slug for lookups
const rulesBySlug = {{ rules_by_slug | tojson | safe }};

// Track loaded data
let loadedData = {};

// Search functionality - initialize with server data
let allActions = [
    ...(serverActions.mcps || []).map(item => ({...item, type: 'MCP'})),
    ...(serverActions.rules || []).map(item => ({...item, type: 'Rule'})),
    ...(serverActions.agents || []).map(item => ({...item, type: 'Agent'}))
];
let searchTimeout = null;

// Initialize search data - no longer needed as data comes from server
// The allActions array is already initialized with server data above

// Filter actions in-place
function filterActions(query) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        const searchClear = document.getElementById('search-clear');
        
        if (!query || query.trim() === '') {
            // Show all items
            showAllItems();
            searchClear.style.display = 'none';
            return;
        }
        
        searchClear.style.display = 'block';
        
        const searchTerm = query.toLowerCase();
        
        // Filter each category
        filterCategory('mcps', searchTerm);
        filterCategory('rules', searchTerm);
        filterCategory('agents', searchTerm);
    }, 200);
}

// Filter items within a category
function filterCategory(categoryType, searchTerm) {
    const menuItem = document.querySelector(`[onclick*="${categoryType}"]`).closest('.menu-item');
    const dropdown = document.getElementById(`dropdown-${categoryType}`);
    
    if (!dropdown) return;
    
    let hasVisibleItems = false;
    
    // Get the data for this category
    const categoryData = serverActions[categoryType] || [];
    
    // Filter top-level items and collect them with scores
    const items = dropdown.querySelectorAll('.dropdown-item:not(.ruleset-children .dropdown-item)');
    const itemsWithScores = [];
    
    items.forEach(item => {
        const itemSlug = item.getAttribute('data-rule-slug') || 
                        item.onclick?.toString().match(/toggleDropdownItem\(this,\s*'([^']+)'/)?.[1];
        
        if (!itemSlug) return;
        
        const itemData = categoryType === 'rules' ? 
            rulesBySlug[itemSlug] : 
            categoryData.find(d => (d.slug || d.name) === itemSlug);
        
        if (!itemData) return;
        
        // Check if item itself matches
        const itemMatch = fuzzyMatch(itemData, searchTerm);
        
        // For rulesets, also check if any children match
        let hasMatchingChildren = false;
        let childrenMaxScore = 0;
        if (itemData.type === 'ruleset' && itemData.children) {
            itemData.children.forEach(childSlug => {
                const childData = rulesBySlug[childSlug];
                if (childData) {
                    const childScore = fuzzyMatch(childData, searchTerm).score;
                    if (childScore > 0) {
                        hasMatchingChildren = true;
                        childrenMaxScore = Math.max(childrenMaxScore, childScore);
                    }
                }
            });
        }
        
        const shouldShow = itemMatch.score > 0 || hasMatchingChildren;
        
        if (shouldShow) {
            // Use the higher score between item match and best child match
            const finalScore = Math.max(itemMatch.score, childrenMaxScore);
            itemsWithScores.push({
                element: item,
                score: finalScore,
                itemMatch: itemMatch,
                hasMatchingChildren: hasMatchingChildren,
                itemSlug: itemSlug,
                itemData: itemData
            });
            hasVisibleItems = true;
        } else {
            item.classList.add('filtered-hidden');
            item.classList.remove('search-match');
        }
    });
    
    // Sort items by relevance score (highest first) and reorder in DOM
    if (searchTerm && itemsWithScores.length > 0) {
        itemsWithScores.sort((a, b) => b.score - a.score);
        
        // Collect all parent elements with their children containers as units
        const parentChildUnits = itemsWithScores.map(itemInfo => {
            const { element, itemMatch, hasMatchingChildren, itemSlug, itemData } = itemInfo;
            const childrenContainer = document.getElementById(`children-${itemSlug}`);
            
            return {
                parentElement: element,
                childrenContainer: childrenContainer,
                itemMatch: itemMatch,
                hasMatchingChildren: hasMatchingChildren,
                itemSlug: itemSlug,
                itemData: itemData
            };
        });
        
        // Reorder by moving each parent-children unit together
        const dropdownContainer = dropdown;
        parentChildUnits.forEach(unit => {
            const { parentElement, childrenContainer, itemMatch, hasMatchingChildren, itemSlug, itemData } = unit;
            
            parentElement.classList.remove('filtered-hidden');
            if (itemMatch.score > 0) {
                parentElement.classList.add('search-match');
            } else {
                parentElement.classList.remove('search-match');
            }
            
            // Move parent element to end (this maintains relative sorted order)
            dropdownContainer.appendChild(parentElement);
            
            // If there's a children container, move it right after the parent
            if (childrenContainer) {
                dropdownContainer.appendChild(childrenContainer);
                
                // Filter children if container is visible
                if (childrenContainer.style.display !== 'none') {
                    filterRulesetChildren(itemSlug, searchTerm);
                }
            }
        });
    } else {
        // No search term, just show/hide without reordering
        itemsWithScores.forEach(itemInfo => {
            const { element, itemMatch, hasMatchingChildren, itemSlug, itemData } = itemInfo;
            element.classList.remove('filtered-hidden');
            if (itemMatch.score > 0) {
                element.classList.add('search-match');
            } else {
                element.classList.remove('search-match');
            }
            
            // If it's a ruleset, filter children
            if (itemData.type === 'ruleset' && itemData.children) {
                const childrenContainer = document.getElementById(`children-${itemSlug}`);
                if (childrenContainer && childrenContainer.style.display !== 'none') {
                    filterRulesetChildren(itemSlug, searchTerm);
                }
            }
        });
    }
    
    // Hide/show the entire category based on whether it has matches
    if (hasVisibleItems) {
        menuItem.classList.remove('filtered-hidden');
    } else {
        menuItem.classList.add('filtered-hidden');
    }
}

// Filter children of a ruleset
function filterRulesetChildren(rulesetSlug, searchTerm) {
    const childrenContainer = document.getElementById(`children-${rulesetSlug}`);
    if (!childrenContainer) return;
    
    const childItems = childrenContainer.querySelectorAll('.dropdown-item');
    const childrenWithScores = [];
    
    childItems.forEach(child => {
        const childSlug = child.getAttribute('data-rule-slug');
        if (!childSlug) return;
        
        const childData = rulesBySlug[childSlug];
        if (!childData) return;
        
        const matchResult = fuzzyMatch(childData, searchTerm);
        
        if (matchResult.score > 0) {
            childrenWithScores.push({
                element: child,
                score: matchResult.score
            });
        } else {
            child.classList.add('filtered-hidden');
            child.classList.remove('search-match');
        }
    });
    
    // Sort children by relevance score (highest first) and reorder
    if (searchTerm && childrenWithScores.length > 0) {
        childrenWithScores.sort((a, b) => b.score - a.score);
        
        childrenWithScores.forEach(childInfo => {
            const { element } = childInfo;
            element.classList.remove('filtered-hidden');
            element.classList.add('search-match');
            
            // Move element to maintain sorted order
            childrenContainer.appendChild(element);
        });
    } else {
        // No search term, just show/hide without reordering
        childrenWithScores.forEach(childInfo => {
            const { element } = childInfo;
            element.classList.remove('filtered-hidden');
            element.classList.add('search-match');
        });
    }
}

// Fuzzy matching function
function fuzzyMatch(item, searchTerm) {
    const displayName = (item.display_name || item.name || '').toLowerCase();
    const tags = (item.tags || []).join(' ').toLowerCase();
    const content = (item.content || '').toLowerCase();
    
    // Combine all searchable text
    const searchableText = `${displayName} ${tags} ${content}`;
    
    // Calculate fuzzy match score
    const score = calculateFuzzyScore(searchableText, searchTerm.toLowerCase());
    
    return {
        score: score,
        text: searchableText
    };
}

// Calculate fuzzy match score using a simple algorithm
function calculateFuzzyScore(text, pattern) {
    if (!pattern) return 1;
    if (!text) return 0;
    
    // Exact match gets highest score
    if (text.includes(pattern)) {
        return 100;
    }
    
    // Check for subsequence match (letters in order but not necessarily consecutive)
    let patternIndex = 0;
    let matches = 0;
    let consecutiveMatches = 0;
    let maxConsecutive = 0;
    
    for (let i = 0; i < text.length && patternIndex < pattern.length; i++) {
        if (text[i] === pattern[patternIndex]) {
            matches++;
            patternIndex++;
            consecutiveMatches++;
            maxConsecutive = Math.max(maxConsecutive, consecutiveMatches);
        } else {
            consecutiveMatches = 0;
        }
    }
    
    // If we didn't match all pattern characters, score is 0
    if (patternIndex < pattern.length) {
        return 0;
    }
    
    // Calculate score based on:
    // - How many characters matched (coverage)
    // - How consecutive the matches were (density)
    // - Length penalty (prefer shorter matches)
    const coverage = matches / pattern.length;
    const density = maxConsecutive / pattern.length;
    const lengthPenalty = pattern.length / text.length;
    
    return Math.floor((coverage * 40 + density * 40 + lengthPenalty * 20));
}

// Show all items (clear filter)
function showAllItems() {
    const hiddenItems = document.querySelectorAll('.filtered-hidden');
    hiddenItems.forEach(item => {
        item.classList.remove('filtered-hidden');
    });
    
    const matchedItems = document.querySelectorAll('.search-match');
    matchedItems.forEach(item => {
        item.classList.remove('search-match');
    });
}

// Clear search
function clearSearch() {
    const searchInput = document.querySelector('.search-input');
    const searchClear = document.getElementById('search-clear');
    
    searchInput.value = '';
    searchClear.style.display = 'none';
    showAllItems();
}

// Handle search keyboard shortcuts
function handleSearchKeydown(event) {
    if (event.key === 'Escape') {
        clearSearch();
    }
}

// Restore action states from unified state
function restoreActionStates() {
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    // First, clear all states and reset loadedData
    loadedData = {};
    
    // Clear MCPs state
    const mcpButton = document.querySelector('[data-theme="yellow"]');
    const mcpDropdown = document.getElementById('dropdown-mcps');
    if (mcpButton && mcpDropdown) {
        mcpButton.classList.remove('toggled', 'expanded');
        mcpDropdown.style.display = 'none';
    }
    
    // Clear Rules state
    const rulesButton = document.querySelector('[data-theme="pink"]');
    const rulesDropdown = document.getElementById('dropdown-rules');
    if (rulesButton && rulesDropdown) {
        rulesButton.classList.remove('toggled', 'expanded');
        rulesDropdown.style.display = 'none';
    }
    
    // Clear Agents state
    const agentsButton = document.querySelector('[data-theme="blue"]');
    const agentsDropdown = document.getElementById('dropdown-agents');
    if (agentsButton && agentsDropdown) {
        agentsButton.classList.remove('toggled', 'expanded');
        agentsDropdown.style.display = 'none';
    }
    
    // Now restore the active states
    // Restore MCPs state
    if (state.isActionCategoryActive('mcps')) {
        if (mcpButton && mcpDropdown) {
            mcpButton.classList.add('toggled');
            mcpButton.classList.add('expanded');
            mcpDropdown.style.display = 'block';
            if (!loadedData['mcps']) {
                loadDropdownData('mcps');
                loadedData['mcps'] = true;
            }
        }
    }
    
    // Restore Rules state
    if (state.isActionCategoryActive('rules')) {
        if (rulesButton && rulesDropdown) {
            rulesButton.classList.add('toggled');
            rulesButton.classList.add('expanded');
            rulesDropdown.style.display = 'block';
            if (!loadedData['rules']) {
                loadDropdownData('rules');
                loadedData['rules'] = true;
            }
        }
    }
    
    // Restore Agents state
    if (state.isActionCategoryActive('agents')) {
        if (agentsButton && agentsDropdown) {
            agentsButton.classList.add('toggled');
            agentsButton.classList.add('expanded');
            agentsDropdown.style.display = 'block';
            if (!loadedData['agents']) {
                loadDropdownData('agents');
                loadedData['agents'] = true;
            }
        }
    }
}

// Export for global use  
window.restoreActionStates = restoreActionStates;
window.loadDropdownData = loadDropdownData;
// Export functions needed by onclick handlers
window.toggleDropdownItem = toggleDropdownItem;
window.toggleRuleset = toggleRuleset;
window.toggleRulesetItems = toggleRulesetItems;
// Export install/remove functions needed by toggle functions
window.installRule = installRule;
window.removeRule = removeRule;
window.installAgent = installAgent;
window.removeAgent = removeAgent;
window.installMCP = installMCP;
window.removeMCP = removeMCP;

// Initialize on load
document.addEventListener('DOMContentLoaded', function() {
    // No need to call initSearchData - data is already loaded from server
    // Wait a bit for workspace manager to initialize
    setTimeout(() => {
        restoreActionStates();
    }, 100);
});

// Toggle ruleset expansion
function toggleRuleset(event, element, rulesetSlug) {
    // Prevent event from bubbling to checkbox
    if (event.target.classList.contains('dropdown-item-checkbox')) {
        return;
    }
    
    const childrenContainer = document.getElementById(`children-${rulesetSlug}`);
    const icon = element.querySelector('.ruleset-expand');
    const ruleset = rulesBySlug[rulesetSlug];
    
    if (!childrenContainer || !ruleset) return;
    
    const isExpanded = element.classList.contains('expanded');
    
    if (isExpanded) {
        // Collapse
        element.classList.remove('expanded');
        childrenContainer.style.display = 'none';
        icon.textContent = '▶';
    } else {
        // Expand
        element.classList.add('expanded');
        childrenContainer.style.display = 'block';
        icon.textContent = '▼';
        
        // Populate children if not already done
        if (childrenContainer.children.length === 0 && ruleset.children) {
            ruleset.children.forEach(childSlug => {
                const childRule = rulesBySlug[childSlug];
                if (childRule) {
                    const childDiv = document.createElement('div');
                    childDiv.className = 'dropdown-item';
                    childDiv.setAttribute('data-rule-slug', childSlug);
                    childDiv.onclick = function() {
                        toggleDropdownItem(this, childSlug, 'rules');
                        updateRulesetCheckbox(rulesetSlug);
                    };
                    childDiv.innerHTML = `
                        <span class="dropdown-item-icon">+</span>
                        <span>${childRule.display_name || childRule.name}</span>
                    `;
                    
                    // Check if this child is already active
                    const state = window.workspaceManager?.getState();
                    if (state && state.isActionItemChecked('rules', childSlug)) {
                        childDiv.classList.add('active');
                        childDiv.querySelector('.dropdown-item-icon').textContent = '−';
                    }
                    
                    childrenContainer.appendChild(childDiv);
                }
            });
            
            // Update checkbox state after populating children
            updateRulesetCheckbox(rulesetSlug);
        }
    }
}

// Toggle all items in a ruleset
function toggleRulesetItems(event, rulesetSlug) {
    event.stopPropagation();
    
    const ruleset = rulesBySlug[rulesetSlug];
    if (!ruleset || !ruleset.children) return;
    
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    // Check current state of all children
    const checkedChildren = ruleset.children.filter(childSlug => 
        state.isActionItemChecked('rules', childSlug)
    );
    
    // If all or some are checked, uncheck all. If none are checked, check all.
    const shouldCheck = checkedChildren.length === 0;
    
    // Toggle all children
    ruleset.children.forEach(childSlug => {
        if (shouldCheck) {
            if (!state.isActionItemChecked('rules', childSlug)) {
                installRule(childSlug);
                state.setActionItemState('rules', childSlug, true);
            }
        } else {
            if (state.isActionItemChecked('rules', childSlug)) {
                removeRule(childSlug);
                state.setActionItemState('rules', childSlug, false);
            }
        }
    });
    
    // Update UI for all visible children
    const childrenContainer = document.getElementById(`children-${rulesetSlug}`);
    if (childrenContainer) {
        const childItems = childrenContainer.querySelectorAll('.dropdown-item');
        childItems.forEach(item => {
            const childSlug = item.getAttribute('data-rule-slug');
            if (childSlug) {
                const icon = item.querySelector('.dropdown-item-icon');
                if (shouldCheck) {
                    item.classList.add('active');
                    if (icon) icon.textContent = '−';
                } else {
                    item.classList.remove('active');
                    if (icon) icon.textContent = '+';
                }
            }
        });
    }
    
    // Update the checkbox appearance
    updateRulesetCheckbox(rulesetSlug);
    
    // Save state
    window.workspaceManager.saveState(window.workspaceManager.currentContextId);
}

// Update ruleset checkbox based on children state
function updateRulesetCheckbox(rulesetSlug) {
    const ruleset = rulesBySlug[rulesetSlug];
    if (!ruleset || !ruleset.children) return;
    
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    const rulesetElement = document.querySelector(`[data-rule-slug="${rulesetSlug}"]`);
    if (!rulesetElement) return;
    
    const checkbox = rulesetElement.querySelector('.dropdown-item-checkbox');
    if (!checkbox) return;
    
    // Count checked children
    const checkedChildren = ruleset.children.filter(childSlug => 
        state.isActionItemChecked('rules', childSlug)
    );
    
    // Update checkbox state
    checkbox.classList.remove('checked', 'partial');
    if (checkedChildren.length === 0) {
        checkbox.textContent = '+';
    } else if (checkedChildren.length === ruleset.children.length) {
        checkbox.classList.add('checked');
        checkbox.textContent = '−';
    } else {
        checkbox.classList.add('partial');
        checkbox.textContent = '−';
    }
}

// Toggle menu button - handles both toggle and expand together
function toggleMenuButton(button, type) {
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    const isToggled = state.isActionCategoryActive(type);
    const dropdown = document.getElementById(`dropdown-${type}`);
    
    // Toggle the button state in unified state
    state.toggleActionCategory(type);
    
    // Update UI based on new state
    if (!state.isActionCategoryActive(type)) {
        button.classList.remove('toggled');
        button.classList.remove('expanded');
        dropdown.style.display = 'none';
        // Remove from context
        removeFromContext(type);
    } else {
        button.classList.add('toggled');
        button.classList.add('expanded');
        dropdown.style.display = 'block';
        // Insert into context
        insertIntoContext(type);
        // Load data if needed
        if (!loadedData[type]) {
            loadDropdownData(type);
            loadedData[type] = true;
        }
    }
    
    // Save state to localStorage
    window.workspaceManager.saveState(window.workspaceManager.currentContextId);
}

// Insert action into context
async function insertIntoContext(type) {
    // No longer auto-install default items
    // Users should explicitly choose which items they want
    // This function is kept for potential future use
}

// Remove action from context
async function removeFromContext(type) {
    // Folding/collapsing categories should NOT remove content
    // This function should only be used when explicitly removing items
    // Category folding should only affect UI visibility, not file content
    
    // If we need to remove all items of a type in the future, 
    // it should be a separate explicit action, not tied to UI folding
}

// Load dropdown data - now just updates the UI state based on what's already rendered
function loadDropdownData(type) {
    // The dropdown items are now rendered server-side with Jinja
    // This function just needs to update the UI state (active/inactive)
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    const container = document.getElementById(`${type}-list`);
    if (!container) return;
    
    // Update each dropdown item's state
    const items = container.querySelectorAll('.dropdown-item');
    items.forEach(item => {
        // Handle ruleset items separately
        if (item.classList.contains('ruleset-item')) {
            const rulesetSlug = item.getAttribute('data-rule-slug');
            if (rulesetSlug) {
                updateRulesetCheckbox(rulesetSlug);
            }
            return;
        }
        
        const itemName = item.getAttribute('data-item-id') || 
                        item.onclick?.toString().match(/toggleDropdownItem\(this,\s*'([^']+)'/)?.[1];
        if (itemName) {
            const isChecked = state.isActionItemChecked(type, itemName);
            const icon = item.querySelector('.dropdown-item-icon');
            if (isChecked) {
                item.classList.add('active');
                if (icon && !item.classList.contains('ruleset-item')) {
                    icon.textContent = '−';
                }
            } else {
                item.classList.remove('active');
                if (icon && !item.classList.contains('ruleset-item')) {
                    icon.textContent = '+';
                }
            }
        }
    });
}

// Toggle individual dropdown item
function toggleDropdownItem(element, itemName, type) {
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    // Toggle in unified state
    state.toggleActionItem(type, itemName);
    const isChecked = state.isActionItemChecked(type, itemName);
    
    // Update UI
    const icon = element.querySelector('.dropdown-item-icon');
    if (isChecked) {
        element.classList.add('active');
        icon.textContent = '−';
        // Install the specific item
        if (type === 'mcps') {
            installMCP(itemName);
        } else if (type === 'rules') {
            installRule(itemName);
        } else if (type === 'agents') {
            installAgent(itemName);
        }
    } else {
        element.classList.remove('active');
        icon.textContent = '+';
        // Remove the specific item
        if (type === 'mcps') {
            removeMCP(itemName);
        } else if (type === 'rules') {
            removeRule(itemName);
        } else if (type === 'agents') {
            removeAgent(itemName);
        }
    }
    
    // Save state to localStorage
    window.workspaceManager.saveState(window.workspaceManager.currentContextId);
}

// Backend integration functions (from previous implementation)
async function installAgent(agentName) {
    try {
        const response = await fetch(`/api/agents/${encodeURIComponent(agentName)}`);
        
        if (response.ok) {
            const data = await response.json();
            const result = data.agents && data.agents[0]; // Get first agent from array
            
            if (result && window.workspaceManager) {
                const state = window.workspaceManager.getState();
                if (state) {
                    // Ensure agentMappings exists
                    if (!state.agentMappings) {
                        state.agentMappings = {};
                    }
                    // Store agent name to path mapping in metadata (for easier removal)
                    const agentPath = `.claude/agents/${result.filename}`;
                    state.agentMappings[agentName] = agentPath;
                    
                    // Mark the agent as checked in action state
                    state.setActionItemState('agents', agentName, true);
                }
                
                // Use includeFile which properly handles saving and rendering
                const agentPath = `.claude/agents/${result.filename}`;
                window.workspaceManager.includeFile(agentPath, result.content);
            }
        }
    } catch (error) {
        console.error(`Error installing agent: ${error.message}`);
    }
}

async function installMCP(mcpName) {
    try {
        const response = await fetch(`/api/mcps/${encodeURIComponent(mcpName)}`);
        
        if (response.ok) {
            const data = await response.json();
            const result = data.mcps && data.mcps[0]; // Get first MCP from array
            
            if (result && result.config && window.workspaceManager) {
                const state = window.workspaceManager.getState();
                if (state) {
                    // Mark the MCP as checked in action state
                    state.setActionItemState('mcps', mcpName, true);
                }
                
                // Get current MCP config or create new one
                let currentConfig = {};
                const mcpFile = window.workspaceManager.getState().files['.mcp.json'];
                if (mcpFile) {
                    try {
                        currentConfig = JSON.parse(mcpFile);
                    } catch (e) {
                        currentConfig = {};
                    }
                }
                
                // Ensure mcpServers exists and add the new MCP
                if (!currentConfig.mcpServers) {
                    currentConfig.mcpServers = {};
                }
                currentConfig.mcpServers[mcpName] = result.config;
                
                // Use includeFile which properly handles saving and rendering
                window.workspaceManager.includeFile('.mcp.json', JSON.stringify(currentConfig, null, 2));
            }
        }
    } catch (error) {
        console.error(`Error installing MCP: ${error.message}`);
    }
}

async function installRule(ruleName) {
    try {
        const response = await fetch(`/api/rules/${encodeURIComponent(ruleName)}`);
        
        if (response.ok) {
            const data = await response.json();
            const result = data.rules && data.rules[0]; // Get first rule from array
            
            if (result && result.content) {
                let currentContent = '';
                if (window.workspaceManager && window.workspaceManager.getState()) {
                    const claudeFile = window.workspaceManager.getState().files['CLAUDE.md'];
                    if (claudeFile) {
                        currentContent = claudeFile;
                    }
                }
                
                const ruleContent = result.content.trim();
                const newContent = currentContent + (currentContent ? '\n' : '') + ruleContent;
                
                if (window.workspaceManager) {
                    // Use includeFile which properly handles saving and rendering
                    window.workspaceManager.includeFile('CLAUDE.md', newContent);
                }
            }
        }
    } catch (error) {
        console.error(`Error installing rule: ${error.message}`);
    }
}

// Remove functions for specific items
async function removeMCP(mcpName) {
    try {
        if (window.workspaceManager && window.workspaceManager.getState()) {
            const state = window.workspaceManager.getState();
            const mcpFile = state.files['.mcp.json'];
            
            if (mcpFile) {
                try {
                    let config = JSON.parse(mcpFile);
                    // Remove the specific MCP from config - use correct property name
                    if (config.mcpServers && config.mcpServers[mcpName]) {
                        delete config.mcpServers[mcpName];
                    }
                    
                    // Check if there are any MCPs left
                    const hasRemainingMCPs = config.mcpServers && Object.keys(config.mcpServers).length > 0;
                    
                    if (hasRemainingMCPs) {
                        // Update the file with cleaned config
                        const newContent = JSON.stringify(config, null, 2);
                        // Use includeFile which properly handles saving and rendering
                        window.workspaceManager.includeFile('.mcp.json', newContent);
                    } else {
                        // No MCPs left, remove the file entirely
                        window.workspaceManager.deleteFile('.mcp.json');
                    }
                } catch (e) {
                    console.error('Error parsing MCP config:', e);
                }
            }
        }
    } catch (error) {
        console.error(`Error removing MCP: ${error.message}`);
    }
}

async function removeRule(ruleName) {
    try {
        // Get the rule content first to know what to remove
        const response = await fetch(`/api/rules/${encodeURIComponent(ruleName)}`);
        
        if (response.ok) {
            const data = await response.json();
            const result = data.rules && data.rules[0]; // Get first rule from array
            const ruleContent = result ? result.content.trim() : '';
            
            if (window.workspaceManager && window.workspaceManager.getState()) {
                const claudeFile = window.workspaceManager.getState().files['CLAUDE.md'];
                if (claudeFile && claudeFile.includes(ruleContent)) {
                    // Remove the rule content
                    const newContent = claudeFile
                        .replace(ruleContent, '')
                        .replace(/\n\n+/g, '\n\n')
                        .trim();
                    
                    // Mark the rule as unchecked in action state
                    const state = window.workspaceManager.getState();
                    if (state) {
                        state.setActionItemState('rules', ruleName, false);
                    }
                    
                    // Check if file is empty or only whitespace
                    if (newContent === '' || newContent.match(/^\s*$/)) {
                        // File is empty, remove it entirely
                        window.workspaceManager.deleteFile('CLAUDE.md');
                    } else {
                        // Use includeFile which properly handles saving and rendering
                        window.workspaceManager.includeFile('CLAUDE.md', newContent);
                    }
                }
            }
        }
    } catch (error) {
        console.error(`Error removing rule: ${error.message}`);
    }
}

async function removeAgent(agentName) {
    try {
        if (window.workspaceManager) {
            const state = window.workspaceManager.getState();
            if (!state) return;
            
            let filesToRemove = [];
            
            // First check if we have a stored mapping for this agent
            if (state.agentMappings && state.agentMappings[agentName]) {
                const mappedPath = state.agentMappings[agentName];
                if (state.files[mappedPath]) {
                    filesToRemove.push(mappedPath);
                }
                // Clean up the mapping
                delete state.agentMappings[agentName];
            }
            
            // If no mapping found, search for the agent file
            if (filesToRemove.length === 0) {
                // Find files in .claude/agents/ directory that match this agent
                filesToRemove = Object.keys(state.files).filter(path => {
                    // Check for both .yaml and .md extensions
                    const normalizedAgentName = agentName.toLowerCase().replace(/[-\s]/g, '[-_]?');
                    const regex = new RegExp(`\.claude/agents/.*${normalizedAgentName}.*\.(yaml|md)$`, 'i');
                    return regex.test(path);
                });
                
                // If still no match, try alternative path patterns
                if (filesToRemove.length === 0) {
                    const alternativePaths = [
                        `.claude/agents/${agentName}.yaml`,
                        `.claude/agents/${agentName}.md`,
                        `.claude/agents/${agentName.replace(/[-\s]/g, '_')}.md`,
                        `.claude/agents/${agentName.replace(/[-\s]/g, '-')}.md`
                    ];
                    
                    alternativePaths.forEach(path => {
                        if (state.files[path]) {
                            filesToRemove.push(path);
                        }
                    });
                }
            }
            
            // Mark the agent as unchecked in action state
            state.setActionItemState('agents', agentName, false);
            
            // Remove all found files - use workspaceManager.deleteFile for proper updates
            if (filesToRemove.length > 0) {
                filesToRemove.forEach(path => {
                    // Use workspaceManager.deleteFile which triggers render
                    window.workspaceManager.deleteFile(path);
                });
                // Save state after agent mappings update
                window.workspaceManager.saveState(window.workspaceManager.currentContextId);
            } else {
                console.warn(`No agent files found for: ${agentName}. Mapped path: ${state.agentMappings?.[agentName] || 'none'}`);
                // Still save state for the action state update
                window.workspaceManager.saveState(window.workspaceManager.currentContextId);
            }
        }
    } catch (error) {
        console.error(`Error removing agent: ${error.message}`);
    }
}
</script>